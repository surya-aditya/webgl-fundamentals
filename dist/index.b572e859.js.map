{"mappings":"AAAA,MAAM;IAGJ,aAAc;QACZ,IAAI,CAAC,MAAM,GAAG,SAAS,cAAc,CAAC;QACtC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;QAEvB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,MAAO,mBAAmB;IAC9C;AACF;AAEA,IAAI,MAGJ,oBAAoB;CACpB,2BAA2B;CAC3B,qCAAqC;CACrC,oDAAoD;CACpD,yCAAyC;CACzC,eAAe;CACf,cAAc;CACd,MAAM;CAEN,0BAA0B;CAC1B,uGAAuG;CACvG,4BAA4B;CAE5B,kDAAkD;CAClD,iFAAiF;CAEjF,uBAAuB;CACvB,mEAAmE;CACnE,qEAAqE;CAErE,4DAA4D;CAC5D,4CAA4C;CAE5C,8EAA8E;CAC9E,oDAAoD;CAEpD,sCAAsC;CAEtC,uBAAuB;CACvB,8BAA8B;CAC9B,2CAA2C;CAE3C,6DAA6D;CAC7D,4DAA4D;CAE5D,2BAA2B;CAC3B,qCAAqC;CAErC,sDAAsD;CACtD,8BAA8B;CAE9B,+BAA+B;CAC/B,6DAA6D;CAE7D,mCAAmC;CACnC,sDAAsD;CAEtD,iFAAiF;CACjF,2DAA2D;CAC3D,yDAAyD;CACzD,yDAAyD;CACzD,6GAA6G;CAC7G,qEAAqE;CACrE,8BAA8B;CAC9B,6EAA6E;CAE7E,uBAAuB;CACvB,6GAA6G;CAC7G,uBAAuB;CACvB,wCAAwC;CACxC,wCAAwC;CACxC,0CAA0C;CAC1C,0CAA0C;CAC1C,2EAA2E;CAE3E,8BAA8B;CAC9B,+EAA+E;CAE/E,yBAAyB;CACzB,oEAAoE;CAEpE,qBAAqB;CACrB,kDAAkD;CAElD,4BAA4B;CAC5B,oCAAoC;CACpC,sBAAsB;CACtB,qBAAqB;CACrB,mDAAmD;CAEnD,wCAAwC;CACxC,MAAM;CACN,IAAI;CAEJ,iCAAiC;CACjC,6CAA6C;CAC7C,mBAAmB;CACnB,yBAAyB;CACzB,2BAA2B;CAC3B,oBAAoB;CACpB,sBAAsB;CACtB,yBAAyB;CACzB,IAAI;CAEJ,UAAU","sources":["webgl/src/scripts/index.ts"],"sourcesContent":["class App {\n  private canvas: HTMLCanvasElement\n\n  constructor() {\n    this.canvas = document.getElementById('c') as HTMLCanvasElement\n    this.canvas.getContext('webgl')\n\n    if (!this.canvas) throw (\"Canvas not found\")\n  }\n}\n\nnew App()\n\n\n// function main() {\n//   // Get A WebGL context\n//   /** @type {HTMLCanvasElement} */\n//   var canvas = document.querySelector(\"#canvas\");\n//   var gl = canvas.getContext(\"webgl\");\n//   if (!gl) {\n//     return;\n//   }\n\n//   // setup GLSL program\n//   var program = webglUtils.createProgramFromScripts(gl, [\"vertex-shader-2d\", \"fragment-shader-2d\"]);\n//   gl.useProgram(program);\n\n//   // look up where the vertex data needs to go.\n//   var positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n\n//   // lookup uniforms\n//   var colorLocation = gl.getUniformLocation(program, \"u_color\");\n//   var matrixLocation = gl.getUniformLocation(program, \"u_matrix\");\n\n//   // Create a buffer to put three 2d clip space points in\n//   var positionBuffer = gl.createBuffer();\n\n//   // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\n//   gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n//   requestAnimationFrame(drawScene);\n\n//   // Draw the scene.\n//   function drawScene(now) {\n//     now *= 0.001;  // convert to seconds\n\n//     // Tell WebGL how to convert from clip space to pixels\n//     gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n//     // Clear the canvas.\n//     gl.clear(gl.COLOR_BUFFER_BIT);\n\n//     // Tell it to use our program (pair of shaders)\n//     gl.useProgram(program);\n\n//     // Turn on the attribute\n//     gl.enableVertexAttribArray(positionAttributeLocation);\n\n//     // Bind the position buffer.\n//     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n//     // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n//     var size = 2;          // 2 components per iteration\n//     var type = gl.FLOAT;   // the data is 32bit floats\n//     var normalize = false; // don't normalize the data\n//     var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n//     var offset = 0;        // start at the beginning of the buffer\n//     gl.vertexAttribPointer(\n//         positionAttributeLocation, size, type, normalize, stride, offset);\n\n//     // Set Geometry.\n//     var radius = Math.sqrt(gl.canvas.width * gl.canvas.width + gl.canvas.height * gl.canvas.height) * 0.5;\n//     var angle = now;\n//     var x = Math.cos(angle) * radius;\n//     var y = Math.sin(angle) * radius;\n//     var centerX = gl.canvas.width  / 2;\n//     var centerY = gl.canvas.height / 2;\n//     setGeometry(gl, centerX + x, centerY + y, centerX - x, centerY - y);\n\n//     // Compute the matrices\n//     var projectionMatrix = m3.projection(gl.canvas.width, gl.canvas.height);\n\n//     // Set the matrix.\n//     gl.uniformMatrix3fv(matrixLocation, false, projectionMatrix);\n\n//     // Draw in red\n//     gl.uniform4fv(colorLocation, [1, 0, 0, 1]);\n\n//     // Draw the geometry.\n//     var primitiveType = gl.LINES;\n//     var offset = 0;\n//     var count = 2;\n//     gl.drawArrays(primitiveType, offset, count);\n\n//     requestAnimationFrame(drawScene);\n//   }\n// }\n\n// // Fill the buffer with a line\n// function setGeometry(gl, x1, y1, x2, y2) {\n//   gl.bufferData(\n//       gl.ARRAY_BUFFER,\n//       new Float32Array([\n//           x1, y1,\n//           x2, y2]),\n//       gl.STATIC_DRAW);\n// }\n\n// main();\n"],"names":[],"version":3,"file":"index.b572e859.js.map","sourceRoot":"/__parcel_source_root/"}